`timescale 1ns / 1ps

module goon(
    input [2:0] in,
    input clk,
    input [3:0] thres,
    output led,
    output [6:0] seg,
    output [3:0] an
);

    wire [4:0] prev;            // Increased from 4 to 5 bits
    wire slow;
    wire reset_fast;
    wire reset_slow;
    wire [4:0] acc;             // Increased from 4 to 5 bits

    acc a1(in, slow, prev, reset_slow, acc);
    store a2(acc, clk, reset_fast, prev);
    clkgen a3(clk, slow);
    comp a4(clk, acc, thres, led, reset_fast);
    decoder d1(acc[3:0], seg);  // Only lower 4 bits for 7-segment display

    assign an = 4'b1110; // Enable only the rightmost 7-segment digit

    // Synchronize reset from fast to slow domain
    reg r1 = 0, r2 = 0;
    always @(posedge slow) begin
        r1 <= reset_fast;
        r2 <= r1;
    end
    assign reset_slow = r2;

endmodule

module acc(
    input [2:0] in,
    input slow,
    input [4:0] prev,
    input reset,
    output reg [4:0] acc
);
    always @(posedge slow or posedge reset) begin
        if (reset)
            acc <= 0;
        else if (prev + in >= 16)
            acc <= 0;
        else
            acc <= prev + in;
    end
endmodule

module store(
    input [4:0] acc,
    input clk,
    input reset,
    output reg [4:0] prev
);
    always @(negedge clk or posedge reset) begin
        if (reset)
            prev <= 0;
        else
            prev <= acc;
    end
endmodule

module clkgen(
    input wire clk,
    output wire slow
);
    reg [25:0] count = 0;
    reg tmp_clk = 0;

    assign slow = tmp_clk;

    always @(posedge clk) begin
        if (count < 25_000_000)
            count <= count + 1;
        else begin
            tmp_clk <= ~tmp_clk;
            count <= 0;
        end
    end
endmodule

module comp(
    input clk,
    input [4:0] acc,
    input [3:0] thres,
    output reg led,
    output reg reset
);
    always @(posedge clk) begin
        if (acc[3:0] > thres) begin
            reset <= 1;
            led <= 1;
        end else begin
            reset <= 0;
            led <= 0;
        end
    end
endmodule

module decoder(
    input [3:0] value,
    output reg [6:0] seg
);
    always @(*) begin
        case(value)
            4'b0000: seg = 7'b0000001; // 0
            4'b0001: seg = 7'b1001111; // 1
            4'b0010: seg = 7'b0010010; // 2
            4'b0011: seg = 7'b0000110; // 3
            4'b0100: seg = 7'b1001100; // 4
            4'b0101: seg = 7'b0100100; // 5
            4'b0110: seg = 7'b0100000; // 6
            4'b0111: seg = 7'b0001111; // 7
            4'b1000: seg = 7'b0000000; // 8
            4'b1001: seg = 7'b0000100; // 9
            4'b1010: seg = 7'b0001000; // A
            4'b1011: seg = 7'b1100000; // B
            4'b1100: seg = 7'b0110001; // C
            4'b1101: seg = 7'b1000010; // D
            4'b1110: seg = 7'b0110000; // E
            4'b1111: seg = 7'b0111000; // F
            default: seg = 7'b1111111; // Off
        endcase
    end
endmodule


